---
title: "Vignette_01_Introduction_Setup"
author: "GAJ"
date: "2024-11-25"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

<h2>Vignette overview and learning objectives</h2>

This first vignette will take you through a brief introduction to RStudio, downloading a local version of the ABISSMAL GitHub repository, and an introduction to the data analysis workflow provided by ABISSMAL. Through this tutorial, you will learn:

1. How to configure your RStudio session
2. How to create a local version of a GitHub repository
3. The data processing and analysis steps provided by the ABISSMAL R functions
4. How to troubleshoot errors online
5. How to report bugs as GitHub issues

There are many different ways to carry out a single task or to solve a single problem in R. Keep this in mind throughout all of these tutorials. In each tutorial, you will learn examples of how to carry out specific tasks or solve specific problems with code, but these examples are not an exhaustive overview of how to address any one task or solve any one problem. Instead, use these tutorials as an opportunity to practice using your coding skills in a biological context.  

<h2>Configure your RStudio session</h2>

If you are new to using R (a programming language for statistical analysis) and RStudio (a graphical user interface for R), then I recommend checking out the introductory lesson [R for Reproducible Scientific Analysis](https://swcarpentry.github.io/r-novice-gapminder/) provided by the [Software Carpentry](https://software-carpentry.org/).

Once you have R and RStudio installed on your computer, you can open RStudio by clicking on the software icon. The default pane configuration for RStudio should look like this (the background color will probably be different):

<br>
![A screenshot of the default RStudio pane configuration, with the console pane below the source pane](/home/gsvidaurre/Desktop/GitHub_repos/ABISSMAL/R/vignettes/images/RStudio_01.png)

This pane layout makes it difficult to see the code that you're writing and saving in a physical file in the source pane, and the output of that code in the console pane. You can reconfigure the panes so that the source and console panes are horizontally adjacent to one another, which makes it easier to immediately check the output of any code that you run. To reconfigure the pane layout:

* Go to the menu along the top bar of the RStudio window and select the option "Tools"

* Select "Global Options" in the pop-up menu

* In the next pop-up menu, select the option "Pane Layout" along the lefthand side

* Use the dropdown menus to select "Source" as the top right pane and "Console" as the top left pane

* You can select "Apply" to apply those changes, then "Ok" to exit this window 

The RStudio pane layout should now look like this:

<br>
![A screenshot of the updated RStudio pane configuration, with the console pane to the right of the source pane](/home/gsvidaurre/Desktop/GitHub_repos/ABISSMAL/R/vignettes/images/RStudio_02.png)

Another useful change to the RStudio configuration is soft-wrapping lines of text and code so that you don't have to scroll horizontally to see long lines of text in your Source pane. To do this, go to "Tools", then "Global Options", then "Code", and check the box next to the option "Soft-wrap R source files", then select "Apply" and "Ok".

You can also change the font size, font color, and background color of your RStudio workspace. After selecting "Tools" and "Global Options", go to "Appearance" to see some different options.

<h2>Create a local version of an existing GitHub repository</h2>

If you are new to using GitHub, then I recommend downloading [GitHub Desktop](https://desktop.github.com/). This software is a graphical user interface for the GitHub version control platform. We will work through how to download the GitHub repository for ABISSMAL so that you can access the ABISSMAL R functions on your local computer. If you are already familiar with GitHub and using Git through the command line, then check out the installation instructions on the [ABISSMAL README](https://github.com/lastralab/ABISSMAL).

Once you have installed GitHub Desktop:

* Open GitHub Desktop by clicking on the icon

* Open your default Internet browser and navigate to the ABISSMAL GitHub repository: https://github.com/lastralab/ABISSMAL

* Click on the green "Code" button and copy the web URL under the HTTPS option in the dropdown menu

* In the GitHub Desktop window, go to the top menu and select "File"

* Select "Clone repository", 

* Select the tab "URL"

* Paste the web URL for ABISSMAL into the text box under "Repository URL or GitHub username and repository"

* Check that the directory in the text box under "Local path" is the correct place to install the ABISSMAL GitHub repository on your computer. For instance, if "Local path" is "/home/User/Desktop/ABISSMAL", then the ABISSMAL repository will be installed directly to your Desktop

* Select "Clone" once you're ready to create a local version of the remote ABISSMAL repository on your computer

Once the repository has been installed on your computer, you should see the following directory and file structure inside the folder labeled "ABISSMAL" that looks similar to this:

<br>
![A screenshot of the directory that is the local ABISSMAL repository](/home/gsvidaurre/Desktop/GitHub_repos/ABISSMAL/R/vignettes/images/ABISSMAL_localrepo.png)

The files that we'll be working with throughout the following vignettes are inside of the "R" folder. This folder contains 6 R files (extension ".R"), a README file that contains more information about each R file, and folders with the vignettes in RMarkdown format (extension ".Rmd") as well as automated unit testing scripts.

<h2>ABISSMAL data processing and analysis</h2>

ABISSMAL provides 5 different R functions for data processing and analysis. These functions are briefly described below in the order in which they should generally be used. The functions are also described in more detail in the R folder README as well as the accompanying methods manuscript:

1. `combine_raw_data` will automatically concatenate spreadsheets of raw data collected each day into a single spreadsheet across days. This data concatenation is performed for a given sensor type (e.g. infrared beam breakers or an infrared video camera) and does not change or overwrite the original raw data. This function can use data from any sensor type (RFID, infrared beam breakers, video camera, or temperature probe) as input, but the following functions do not accept data from the temperature probe

2. `detect_perching_events` uses the output of `combine_raw_data` as input, and will detect stretches of detections that occurred close together in time as perching events. These events represent periods of time when an individual was perched in the RFID antenna in the nest container entrance. This function returns a spreadsheet of the timing of inferred perching events detected using data from sensors placed around the nest container entrance (RFID or infrared beam breakers)

3. `preprocess_detections` uses the output of `combine_raw_data` as input, and removes detections that occurred very close together in time. This function returns a spreadsheet of pre-processed data per sensor type, in which consecutive detections are all separated by no less than a given temporal threshold (e.g. when using a threshold of 1 second, only a single detection can occur per second)

4. `detect_clusters` uses the output of `preprocess_detections` from any 2 or more movement sensor types as input. This function identifies detections across 2+ sensor types that occurred close together in time, and returns temporal information and metadata about each detection cluster. Detection clusters represent discrete movement events by one or more individuals

5. `score_clusters` uses the output of `detect_clusters` as the main input. This function can also use the output of `detect_perching_events` to integrate perching events detected in the raw RFID or infrared beam breaker datasets. It can also use the output of `preprocess_detections` to integrate video recording events that were not detected by `detect_clusters`. This function serves to make behavioral inferences about each movement event, including the direction of movement, the magnitude of movement, individual identity when RFID data was present in a cluster, and where the beginning of the movement event likely occurred (at the container entrance or inside of the container). This function returns a spreadsheet of behavioral inferences and other metadata about each movement event that can be used for subsequent analyses and visualization

<br>
![Figure 4 from the ABISSMAL methods manuscript under review, that shows a general workflow across these 5 functions](/home/gsvidaurre/Desktop/GitHub_repos/ABISSMAL/R/vignettes/images/Figure4_ComputationalAnalyses.png)
* Figure from Smith-Vidaurre, G., Molina, T., Jarvis, E.D., and E.A. Hobson. 2023. Automated tracking of avian parental care. [EcoEvoRxiv preprint]((https://ecoevorxiv.org/repository/view/6268/)).

<h2>Troubleshoot errors online</h2>

You will run into errors while writing and running code, and while this can be frustrating, errors are an important part of the overall learning experience. Errors can arise for many different reasons, including typos that you introduced while writing code, issues with package versions that you installed, or perhaps missing packages. Sometimes, errors may be due to issues with the custom ABISSMAL functions that you will use in the subsequent vignettes, or issues with the code in the vignettes themselves. 

Whenever you run into an error with your code, it's important to troubleshoot the error and figure out out how to solve it before assuming that the error is due to the custom ABISSMAL functions or issues with the ABISSMAL vignettes. There are many different resources online that you can use to troubleshoot common errors in R. One way to start troubleshooting errors online is to copy and paste the error message printed to your console into a search engine, which should point you to public forums online in which people have asked about and solved similar errors. You may also be able to use generative AI tools like ChatGPT to search for potential typos or issues with your code. You can also read R documentation to figure out if the error is associated with a specific package or function upon which ABISSMAL depends.

Once you have thoroughly researched a given error, and you're sure that the error you're getting isn't due to a typo or issues with data structure on your end, then it's time to consider whether the error is due to a bug in a custom ABISSMAL function or the code provided in a vignette. These are bugs that you can report to the ABISSMAL developers on GitHub (see below).

<h2>Report bugs on GitHub</h2>

As you work through each vignette, you may encounter "bugs" or errors with the code, including code that does not work or that yields incorrect outcomes. These bugs can occur with the ABISSMAL functions themselves, or with the code in a given vignette. When you encounter a bug with an ABISSMAL function, you can create an Issue through the GitHub repository. To create a new Issue, you can select "New Issue" on the [Issues page](https://github.com/lastralab/ABISSMAL/issues) of the main ABISSMAL repository, then follow the instructions in the Issue template to add the information needed for the code developers to address the bug effectively. You can also add the tag "bug" to your issue. If you encounter an issue with the ABISSMAL vignettes, then you can submit an issue through the main ABISSMAL GitHub repository as well, as long as you clarify that the bug is related to code in a given vignette.

In the next vignette, we will create simulated datasets of raw movement data to learn how to use the different ABISSMAL functions described above.

```{r setup, include = FALSE}

knitr::opts_chunk$set(echo = TRUE, eval = FALSE)

```

<h2>Vignette overview and learning objectives</h2>

In this second vignette, we will set up a virtual workspace for coding sessions with the ABISSMAL R functions. You will learn basic R programming skills and open science tips for writing code, including:

1. How to use RMarkdown files
2. Cleaning your global environment
3. Running code inside of an RMarkdown chunk
4. Learning about R functions and documentation
5. Installing and loading packages
6. Commenting code
7. Coding shortcuts in RStudio
8. Creating and using a working directory

<h2>Using RMarkdown files</h2>

Each vignette in this series is available as an RMarkdown file (extension .Rmd) and as an HTML file that can be viewed in your default Internet browser. Each HTML file was generated by knitting the output of an RMarkdown file. You can check out the [RMarkdown documentation](https://rmarkdown.rstudio.com/lesson-1.html) for more information about how to use this file format to write code and knit the code output into reports.

RMarkdown files facilitate sharing your code and the output of your code with others. If you're new to using RMarkdown, the best way to work through these vignettes will be to create a new RMarkdown file for each vignette and write out the code from each vignette yourself. You will get the most coding practice out of these vignettes if you write out the code and comments in your own words (outside and inside of chunks). You can open the knitted output for each vignette in your Internet browser as a guide while you write code in your own RMarkdown file. Or you can open the vignette RMarkdown file and your own RMarkdown file side by side in RStudio by adding a third column in the pane layout:

* Tools
* Global Options
* Pane Layout
* Select the Add Column option to add another Source pane in a third column
* Open the original vignette RMarkdown file in one source pane, and your own RMarkdown file in the other source pane

If you're already familiar with writing R code and using RMarkdown files, then you can open the original RMarkdown file for each vignette and run the code inside each file as you work through each vignette (with some modification of paths to reflect folders and files on your local computer). If you want to preserve the original code in each RMarkdown file, you can create a copy of each vignette and modify the copies instead. 

<h2>Clean your global environment</h2>

Your global environment is your virtual workspace in R, and can hold different packages and objects to facilitate your data analysis and programming objectives. You can see the different packages and objects currently loaded in your environment by clicking on the tab "Environment" in the pane that also includes the "History" and "Connections" tab. 

If you started a new RStudio session then your global environment will likely be empty. But if you're working in an older session or maybe in an RProject workspace, then your global environment will likely have packages and objects already loaded. Cleaning your global environment can be good practice to ensure that you're starting a new coding session with a fresh workspace. If you don't clean your global environment, even when using the same code between sessions, then you risk using old versions of objects that don't reflect your newest changes to the code.

You can clean your global environment directly from the RStudio interface by clicking on the broom icon below the "Environment" tab (hit "Yes" with "hidden objects" selected). 

You can also clean your global environment by running the code below. You can run the code inside this chunk in different ways:

* Click on the small green arrow icon on the top right side of the chunk to run the code in this chunk only

* Place your cursor anywhere within the line of code, then go up to the "Run" icon on the top right of the Source pane that has a white square and green arrow. In the dropdown menu that appears, select "Run Selected Lines" or "Run Current Chunk" (see the keyboard shortcuts next to each)

* Place your cursor anywhere within the line of code and use the keyboard shortcut Ctrl + Enter to run the current line of code

* Place your cursor anywhere within the line of code and use the keyboard shortcut Ctrl + Shift + Enter to run all code in the current chunk

The first keyboard shortcut to run one line of code at a time can be helpful to see the output of each line of code at a time and check for errors.
```{r}

rm(list = ls())

```

The code above to clean your global environment is a nested expression with 2 functions: `rm()` and `ls()`. The `()` notation is used for functions in R. Functions are operations that you can apply in your own code by using the name of a specific function. R has a set of base functions that you can access without loading any additional packages, including the two functions above (`rm()` and `ls()`).

<h2>Access R function documentation</h2>

You can access the documentation for these functions by clicking on the "Help" tab in the pane that also has "Files" and "Plots", and typing the name of the function in the search bar. You can also access function documentation by running the following code:
```{r}

?rm

```

```{r}

?ls

```

For each function, the documentation holds specific sections that can be useful for understanding how the function works, especially the function's arguments. A function's arguments are the values that it expects the user to provide in order to guide or customize the operation. Many functions will have preset default values for some arguments that will be used when you don't provide specific values for arguments. 

For instance, the function `rm()` has an argument called `list` (followed by an `=`, which is used to pass a specific value to the argument). In order for `rm()` to clean your global environment in the way that you want, you need to provide information after the argument `list`. To remove everything in your global environment, we're using the output of the function `ls()`, which is a function that lists the names of all of the objects in your global environment.

<h2>Install and load packages</h2>

After cleaning the global environment, you still need to set up your virtual workspace for the upcoming coding session. One important step here is to make sure you have access to functions that you need but which aren't accessible through the base R functions. For instance, [the `tidyverse`](https://www.tidyverse.org/) is a set of R packages that provide useful functions and expressions for data science purposes. 

If you don't already have tidyverse installed on your local computer, then you need to install the tidyverse in order to access these functions. The code below installs the tidyverse from [CRAN](https://cran.r-project.org/), the Comprehensive R Archive Network that holds thousands of R packages online.
```{r}

# Install the tidyverse from CRAN
install.packages("tidyverse")

```

In the chunk above, I added a comment using the `#` symbol. Any text that you write after a `#` symbol will be treated as text and will not be run as code. It's good practice to comment your code, especially as you're learning more about how to code in R. For biologists, continuing to comment your code even when you're a coding expert can also be good practice. Commenting and documenting your work makes the code that you publish with manuscripts or software tools more accessible to others in the community.

Once you've installed the tidyverse on your computer, you do not need to install it again. But you do need to use the function `library()` to load the package into your global environment in order to access functions that are held inside of the tidyverse packages:
```{r}

library(tidyverse)

```

<h2>Coding shortcuts</h2>

RStudio has a number of useful keyboard shortcuts for writing code. You can find these shortcuts by going to Tools at the header of the RStudio window, then Keyboard Shortcuts Help, which will pull up a popup window with all of the default keyboard shortcuts. You already learned some keyboard shortcuts above about how to run code inside of an RMarkdown chunk. Some additional useful keyboard shortcuts are "Shift + Ctrl + C", which can be used to comment one or multiple lines of code or create new comments, and "Ctrl + Alt + I", which automatically creates a new RMarkdown chunk.

Another useful type of shortcut provided by RStudio is tab completion of code. For instance, in the chunk below, after writing `libr` and pressing Tab, you should see a small popup window appear that lists all of the available functions, packages, or objects that start with the pattern "libr". You can use the arrow keys to select the option that you'd like and hit Enter to complete the line (for instance, to write `library()` for loading a package).
```{r eval = FALSE}

libr

```

<h2>Troubleshooting incomplete statements</h2>

As you write and run code in RStudio, it's important to keep an eye on the console. When you see the symbol `>` in the console, this means that the console finished running code and is ready for another operation. However, when you see the symbol `+` in the console, this means that the statement you just ran was incomplete. Incomplete lines of code can occur when you have a typo so that a statement isn't fully closed, like when you miss an opening or closing parenthesis in a function. Below is an example of an incomplete statement:
```{r eval = FALSE}

library(tidyverse

```

When you run the code above, you should see a `+` symbol appear in the console. This is because you're missing a parenthesis to close the function `library()`. There are two ways to solve this problem. First, if you know what is missing from the statement, you can type the missing bit into the console and hit "Enter". Or, you can click in the console, and then press "Esc", which will remove the incomplete statement and restart the console for additional code. It's good practice to keep an eye on the console to check that the code you're running is producing output. If you run a lot of code and don't see the output that you expect, it may be because you included an incomplete statement, and it would be better to clean the console and check your code before running it again.

<h2>Create your working directory</h2>

The next important step for setting up your virtual workspace is to decide on the working directory that you will use for the coding session. A directory is a location (a folder) on your computer where R will search for files to read in. When you write out files from R, those files can also be written to your working directory.

You can use the function `getwd()` to check your current working directory.
```{r eval = TRUE}

getwd()

```

My working directory is set by default to the folder on my computer where I saved this RMarkdown file. To work in a separate directory that holds only data generated from these vignettes, you can create a new directory or folder on your computer:
```{r}

?dir.create

dir.create("/home/gsvidaurre/Desktop/ABISSMAL_vignettes")

```

In the code above, you'll need to replace the path (or the list of folder names) to reflect where you want to save the new folder called `ABISSMAL_vignettes` (or another name of your choice) on your own computer. For those using Windows, if you copy and paste a path into R directly from your computer then you may need to change the direction of the slashes.

In introductory R coding courses, it's common to formally set your working directory before a coding session by using the function `setwd()`. It's good practice to avoid using `setwd()` in code that that you want to share with collaborators or share more widely in the spirit of open science (e.g. accompanying a publication or a new tool). When you use `setwd()` and share the code with others, you're assuming that someone else has the same working directory on their computer, which generally will not be true. There are other ways in which you can specify your working directory throughout your code without using `setwd()`.

For instance, let's say that we want to make a copy of the first vignette and then save that copy inside of the directory that we created above. We can use a base R functions to copy and save the file to the correct working directory. You will need to update the paths below to reflect the folder where the vignettes are saved on your computer, as well as your own working directory:
```{r}

file.copy(
  from = "/home/gsvidaurre/Desktop/GitHub_repos/ABISSMAL/R/vignettes/Vignette_01_Introduction.Rmd",
  to = "/home/gsvidaurre/Desktop/ABISSMAL_vignettes/Vignette_01_Introduction_copy.Rmd"
    )

```

In the code above, we're specifying 2 arguments to the function `file.copy()`. The first argument specifies the location of the file that we want to copy (/home/gsvidaurre/Desktop/GitHub_repos/ABISSMAL/R/vignettes/) and the name of the file (Vignette_01_Introduction.Rmd). The second argument specifies the location where we want to save this copy (/home/gsvidaurre/Desktop/ABISSMAL_vignettes/), and a new file name for the copied file (Vignette_01_Introduction_copy.Rmd). In each argument, the file paths are surrounded by 2 double quotes, in order to indicate that the text inside each pair of quotes should be considered character information or a "character string" (a formal term for text included in R code).

When you run the line of code above, the output in the console should read "[1] TRUE" if the file was successfully copied and saved. You can check that the function worked correctly by opening a file window on your computer in this new directory. You can also use the base R function `list.files()` to check whether the copied file exists in the working directory. The output of `list.files()` is a list of all of the files contained within the new directory, and that list should contain a single file: "Vignette_01_Introduction_copy.Rmd".
```{r}

list.files(path = "/home/gsvidaurre/Desktop/ABISSMAL_vignettes")

```

The code above is an example of how you can specify your working directory in the code that you write without needing to use `setwd()`. In the following vignettes, you will see other examples of how to specify your working directory without `setwd()`. Before moving on to the next vignette, you can remove the file that you copied to your working directory:

```{r}

file.remove("/home/gsvidaurre/Desktop/ABISSMAL_vignettes/Vignette_01_Introduction_copy.Rmd")

```

In the next vignette, you will start creating and manipulating objects in R that can be used in the ABISSMAL data processing and analysis pipeline.

Vignette 1: Setting up your workspace in R
Before you start using the paRsynth package, we need to setup and install R and R studio on your computer.
Install R and RStudio
To install R on your computer, go to the R project website and download the latest version of R for your operating system (Windows, macOS, or Linux). Follow the installation instructions provided on the site.
To install RStudio on your computer, go to the RStudio website. RStudio is an integrated development environment (IDE) that makes working with R a better and more user-friendly experience.
GitHub Setup
In addition to installing R and R Studio, you will need to install GitHub Desktop to have the paRsynth GitHub repository on your local machine
Open the paRsynth GitHub repository on your internet browser, you can use this link 
Click on the arrow of the green "Code" button
Click on the copy link icon
Install GitHub Desktop by going to this website and clicking "Download Now"
In the top left toolbar, click on File > Clone Repository
Paste the URL 
Make sure the "Local Path" is where you want the paRsynth repository to be located on your local machine
Click on the blue "Clone" button 
You should be able to see it the local path of your machine that you assigned it
Purpose of the package
paRsynth provides four functions for the simulation of vocalisations with representation of both individual identity and group membership informations. These vocalizations are encoded as strings that can be used for generating synthetic audio signals for bioacoustic analysis. This vignette will demonstrate how to use the package's functions to generate vocalisation strings, convert them into Parsons code, calculate frequency anchors, and generate synthetic audio files.
Introduce the 4 functions with descriptions of what they do
Give an overview of the package (like a simple one sentence intro):
generate_strings(): generates strings that encode group membership information and individual identity information.
parsons_code(): converts the generated strings (characters) into Parsons code (musical up-down-constant connotation) for frequency modulation.
frequency_anchors(): calculates frequency anchors (numeric values that correspond to each segment of the Parsons code string) from Parsons code to guide the creation of synthetic audio.
write_audio(): uses frequency anchors and the 'soundgen' package to generate and save synthetic audio files.
Add the graphic workflow that illustrates how the functions work together with descriptive caption