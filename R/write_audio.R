#' Save synthetic audio for each string in a data frame
#'
#'@author Ari Cross, Grace Smith-Vidaurre
#'
#'@description `write_audio` function loops through each row in the data frame and uses the `gen_synth_signal` function, which is a wrapper for the `soundgen::soundgen()`, to generate and save audio files in .WAV format for each string.
#'
#' @param df Data frame. A data frame object generated by `frequency_anchors()` that contains the frequency anchor values and string metadata.
#' @param save_path Character string. The directory where the sound files will be saved on your machine.
#' @param sampling_rate Numeric value. The sampling rate for the audio file, in Hz. The default is 150000. This is an argument used directly by `soundgen::soundgen()`.
#' @param sylLen Numeric value. The length of the syllable in milliseconds. The default is 200 ms. This is an argument used directly by `soundgen::soundgen()`.
#' @param prefix Character string. A prefix for each audio file name that can be used to distinguish among calls for different datasets, for instance "IndividualSignatures" versus "GroupSignatures" when creating datasets with more or less individual versus group information. The default is "IndividualSignatures".
#'
#' @details This function uses the frequency anchors generated by `frequency_anchors()` to create a synthetic frequency modulated vocalization that contains specific levels of group and individual information. The information about social affiliation or individual identity is contained in the frequency modulation patterns and their convergence or divergence with respect to group members.This function relies on the `soundgen` package to create synthetic audio files. The current version of this function uses the general default values in the `soundgen::soundgen()` package, which can be further customized as needed to add or remove different acoustic features from the synthetic files.
#'
#' @return This function writes one audio file per vocalization (row) in the input data frame. Each aduio file name contains the group, individual, and call identifiers, as well as the prefix supplied to the function. The function also returns the input data frame with an additional column that contains the name of each audio file, which can be used in downstream bioacoustics analyses.
#'
#' @examples
#' seed <- 8
#' set.seed(seed) # For reproducibility
#' library(tidyverse)
#'
#' example_calls <- generate_strings(n_groups = 2, n_individuals = 5, n_calls = 10, string_length = 16, group_information = 8, individual_information = 2)
#'
#' example_calls_parsons <- parsons_code(example_calls, "Call", list("A" = "up", "B" = "down", "C" = "constant"))
#'
#' anchors <- frequency_anchors(example_calls_parsons, "Parsons_Code", "Group", "Individual", "Call_ID", "Call", starting_frequency = 4000, frequency_shift = 1000)
#'
#' path <- "~/Desktop" # Update this path to reflect your own directory structure
#' tmp_dir <- "testing"
#' tmp_path <- file.path(path, tmp_dir)
#'
#' # Create the temporary directory if it doesn't already exist
#' if(!dir.exists(tmp_path)){
#'  dir.create(tmp_path)
#' }
#'
#' # Write out a randomly subsample of the full dataset of vocalizations
#' set.seed(seed)
#' inds <- sample(1:nrow(anchors), 10, replace = FALSE)
#' write_audio(anchors[inds, ], save_path = tmp_path, sampling_rate = 150000, sylLen = 200, prefix = "IndividualSignatures")
#'
#' # Remove the temporary directory and all files within it
#' if(tmp_path == file.path(path, tmp_dir)){
#'  unlink(tmp_path, recursive = TRUE)
#' }
#'
#' @export write_audio
library(magrittr)

write_audio <- function(df, save_path, sampling_rate = 150000, sylLen = 200, prefix = "IndividualSignatures") {

  if (!is.data.frame(df)) {
    stop("The 'df' argument must be a data frame.")
  }
  if (nrow(df) == 0) {
    stop("Input data frame is empty")
  }
  if (!all(c("Group", "Individual", "Call_ID") %in% colnames(df))) {
    stop("One or more columns were not found in the data frame")
  }
  if (!is.character(save_path)) {
    stop("The 'save_path' argument must be a character string.")
  }
  if (sampling_rate <= 0) {
    stop("sampling_rate must be a positive value")
  }
  if (sylLen <= 0) {
    stop("sylLen must be a positive value")
  }
  if (!is.numeric(sampling_rate)) {
    stop("The 'sampling_rate' argument must be a numeric value.")
  }
  if (!is.numeric(sylLen)) {
    stop("The 'sylLen' argument must be a numeric value.")
  }
  if (!is.character(prefix)) {
    stop("The 'prefix' argument must be a character string.")
  }

    # Ensure the save path exists
  if (!dir.exists(save_path)) {
    dir.create(save_path, recursive = TRUE)
  }

  df2 <- data.table::rbindlist(lapply(seq_len(nrow(df)), function(i) {
    # Extract frequencies from the data frame
    frequencies <- as.numeric(df[i, grep("^Frequency", colnames(df))])

    # Construct the audio filename with a unique identifier
    audio_filename <- paste0(prefix, "_Group", df$Group[i], "_Ind", df$Individual[i],"_Call", df$Call_ID[i], ".wav")

    audio_pathname <- file.path(save_path, audio_filename)

    # Generate and save the WAV file
    gen_synth_signal(frequencies, audio_pathname, sampling_rate = sampling_rate, sylLen = sylLen)

    return(
      df[i, ] %>%
        dplyr::mutate(
          audio_file_name = audio_filename
        )
    )

  }))

  return(df2)

}

# A helper function to generate a synthetic audio signal in .wav format from a vector of frequencies using the `soundgen` package

# Aurguments
# frequencies - A numeric vector of frequency values.
# audio_filename - The name of the audio file that will be written.
# sampling_rate - The sampling rate for the audio file.
# sylLen - The length of the syllable in milliseconds.

# Example usage:
# frequencies <- c(4000, 5000, 4000, 4000, 5000, 4000)
# audio_filename <- "output.wav"
# sampling_rate <- 150000
# sylLen <- 200
# gen_synth_signal(frequencies, audio_filename, sampling_rate, sylLen)

library(soundgen)

gen_synth_signal <- function(frequencies, audio_filename, sampling_rate, sylLen) {

  # Adjust pitch floor and ceiling based on the sampling rate
  pitch_floor <- 1 # this is the default value in soundgen
  pitch_ceiling <- sampling_rate / 2 # Nyquist rule for sampling rate and max frequency

  # Generate a synthetic audio file from the frequency anchors using the soundgen package
  sound_wave <- suppressMessages(soundgen(
    pitch = frequencies,
    samplingRate = sampling_rate,
    sylLen = sylLen,
    pitchFloor = pitch_floor,
    pitchCeiling = pitch_ceiling,
    saveAudio = audio_filename
  ))

}


