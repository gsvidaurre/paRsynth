#' Convert character strings to Parsons code
#'
#'@author Ari Cross, Grace Smith-Vidaurre, Raneem Samman
#'
#'@description This function converts the character strings generated by `generate_strings()` into Parsons code.
#'
#' @param df Data frame. A data frame object produced by `generate_strings()`. Each row is a string of characters representing a vocalization.
#' @param string_col Character string. The name of the column in `df` that contains the strings.
#' @param global_head_col Character string. The name of the column in `df` that contains the global head information.
#' @param group_head_col Character string. The name of the column in `df` that contains the group head information.
#' @param individual_middle_col Character string. The name of the column in `df` that contains the individual middle information.
#' @param random_variation_col Character string. The name of the column in `df` that contains the random variation information.
#' @param group_tail_col Character string. The name of the column in `df` that contains the group tail information.
#' @param global_tail_col Character string. The name of the column in `df` that contains the global tail information.
#' @param mapping List. A list for Parsons code mapping. Each list element contains each character value and its corresponding directionality in Parsons code. The default mapping are the first three letters of the alphabet in uppercase. This creates a mapping for 1-base Parsons code (three unique directions: up, down, and constant).
#' @importFrom magrittr %>%
#' @importFrom rlang sym
#' @importFrom dplyr mutate
#'
#' @details This function converts the character strings generated by `generate_strings()` into Parsons code. The current version of this function was written for 1-base Parsons code and has not been tested for finer-grained Parsons code. The assignment of character values to each Parsons code value is subjective, and changing this mapping will change how frequency modulation patterns are generated downstream.
#'
#' @return This function returns the same data frame that was used as input for the function with an additional column of the string converted to Parsons code.
#'
#' @examples
#' seed <- 8
#' set.seed(seed) # For reproducibility
#' library(tidyverse)
#'
#' example_calls <- generate_strings(n_groups = 2,
#'                                    n_individuals = 5,
#'                                    n_calls = 10,
#'                                    string_length = 16,
#'                                    group_information = 8,
#'                                    individual_information = 2,
#'                                    random_variation = 2)
#'
#' example_calls_parsons <- parsons_code(example_calls,
#'                                       "Call",
#'                                       "Global_head",
#'                                       "Group_head",
#'                                       "Individual_middle",
#'                                       "Random_variation",
#'                                       "Group_tail",
#'                                       "Global_tail",
#'                                       list("A" = "up",
#'                                            "B" = "down",
#'                                            "C" = "constant")
#'                                 )
#' glimpse(example_calls_parsons)
#'
#' @export parsons_code

parsons_code <- function(df, string_col, global_head_col, group_head_col,
                individual_head_col, individual_tail_col, individual_complete_col, group_complete_col,
                random_variation_col, group_tail_col, global_tail_col, string_structure_col,
                mapping = list("A" = "up", "B" = "down", "C" = "constant")) {

  if (!is.data.frame(df)) {
    stop("The 'df' argument must be a data frame.")
  }
  if (!is.null(mapping) && !is.list(mapping)) {
    stop("The 'mapping' argument must be a list if it is not NULL.")
  }
  if (!is.character(string_col) || !is.character(global_head_col) | !is.character(group_head_col) ||
      !is.character(individual_head_col) || !is.character(individual_tail_col) || !is.character(random_variation_col) ||
      !is.character(group_tail_col) || !is.character(global_tail_col)) {

    stop("All vocalization columns argument must be a character string.")
  }

  if (nrow(df) == 0) {
    stop("Input data frame is empty")
  }
  if (!string_col %in% colnames(df) || 
        !global_head_col %in% colnames(df) ||
        !group_head_col %in% colnames(df) ||
        !individual_head_col %in% colnames(df) ||
        !individual_tail_col %in% colnames(df) ||
        !random_variation_col %in% colnames(df) ||
        !group_tail_col %in% colnames(df) || 
        !global_tail_col %in% colnames(df)) {
    stop("One of the string columns provided does not exist in the data frame.")
  }

  # Convert all character string columns to Parsons code if group and individual information were specified (not NA)
  if (!any(is.na(df[[group_head_col]])) &&
        !any(is.na(df[[group_tail_col]])) &&
        !any(is.na(df[[individual_head_col]])) &&
        !any(is.na(df[[individual_tail_col]]))) {

    res <- df %>%
      dplyr::mutate(Call_Parsons_Code = sapply(!!rlang::sym(string_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
      dplyr::mutate(Global_Head_Parsons_Code = sapply(!!rlang::sym(global_head_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
      dplyr::mutate(Group_Head_Parsons_Code = sapply(!!rlang::sym(group_head_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
      dplyr::mutate(Group_Complete_Parsons_Code = sapply(!!rlang::sym(group_complete_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
      dplyr::mutate(Individual_Head_Parsons_Code = sapply(!!rlang::sym(individual_head_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
      dplyr::mutate(Individual_Tail_Parsons_Code = sapply(!!rlang::sym(individual_tail_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
      dplyr::mutate(Individual_Complete_Parsons_Code = sapply(!!rlang::sym(individual_complete_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
      dplyr::mutate(Random_Variation_Parsons_Code = sapply(!!rlang::sym(random_variation_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
      dplyr::mutate(Group_Tail_Parsons_Code = sapply(!!rlang::sym(group_tail_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
      dplyr::mutate(Global_Tail_Parsons_Code = sapply(!!rlang::sym(global_tail_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-")))

    # Convert all columns except the group membership strings if no group membership information was specified
  } else if(any(is.na(df[[group_head_col]])) & any(is.na(df[[group_tail_col]]))) {
    

    res <- df %>%
      dplyr::mutate(Call_Parsons_Code = sapply(!!rlang::sym(string_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
      dplyr::mutate(Global_Head_Parsons_Code = sapply(!!rlang::sym(global_head_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
      dplyr::mutate(Group_Head_Parsons_Code = !!rlang::sym(group_head_col)) %>%
      dplyr::mutate(Group_Complete_Parsons_Code = !!rlang::sym(group_complete_col)) %>%
      dplyr::mutate(Individual_Head_Parsons_Code = sapply(!!rlang::sym(individual_head_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
      dplyr::mutate(Individual_Tail_Parsons_Code = sapply(!!rlang::sym(individual_tail_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
      dplyr::mutate(Individual_Complete_Parsons_Code = sapply(!!rlang::sym(individual_complete_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
      dplyr::mutate(Random_Variation_Parsons_Code = sapply(!!rlang::sym(random_variation_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
      dplyr::mutate(Group_Tail_Parsons_Code = !!rlang::sym(group_tail_col)) %>%
      dplyr::mutate(Global_Tail_Parsons_Code = sapply(!!rlang::sym(global_tail_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-")))

    # Convert all columns except the individual identity string if no individual identity information was specified
  } else if(any(is.na(df[[individual_head_col]])) & any(is.na(df[[individual_tail_col]]))) {
    
    res <- df %>%
      dplyr::mutate(Call_Parsons_Code = sapply(!!rlang::sym(string_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
      dplyr::mutate(Global_Head_Parsons_Code = sapply(!!rlang::sym(global_head_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
      dplyr::mutate(Group_Head_Parsons_Code = sapply(!!rlang::sym(group_head_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
      dplyr::mutate(Group_Complete_Parsons_Code = sapply(!!rlang::sym(group_complete_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
      dplyr::mutate(Individual_Head_Parsons_Code = !!rlang::sym(individual_head_col)) %>%
      dplyr::mutate(Individual_Tail_Parsons_Code = !!rlang::sym(individual_tail_col)) %>%
      dplyr::mutate(Individual_Complete_Parsons_Code = !!rlang::sym(individual_complete_col)) %>%
      dplyr::mutate(Random_Variation_Parsons_Code = sapply(!!rlang::sym(random_variation_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
      dplyr::mutate(Group_Tail_Parsons_Code = sapply(!!rlang::sym(group_tail_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
      dplyr::mutate(Global_Tail_Parsons_Code = sapply(!!rlang::sym(global_tail_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-")))
  }

  return(res)

}

# Helper function to generate Parsons code for existing sequences
convert_to_parsons_code <- function(string, mapping) {
  sapply(strsplit(string, NULL)[[1]], function(char) mapping[[char]], USE.NAMES = FALSE)
}