#' Convert character strings to Parsons code
#'
#'@author Ari Cross, Grace Smith-Vidaurre
#'
#'@description This function converts the character strings generated by `generate_strings()` into Parsons code.
#'
#' @param df Data frame. A data frame object produced by `generate_strings()`. Each row is a string of characters representing a vocalization.
#' @param string_col Character string. The name of the column in `df` that contains the strings.
#' @param mapping List. A list for Parsons code mapping. Each list element contains each character value and its corresponding directionality in Parsons code. The default mapping are the first three letters of the alphabet in uppercase. This creates a mapping for 1-base Parsons code (three unique directions: up, down, and constant).
#'
#' @details This function converts the character strings generated by `generate_strings()` into Parsons code. The current version of this function was written for 1-base Parsons code and has not been tested for finer-grained Parsons code. The assignment of character values to each Parsons code value is subjective, and changing this mapping will change how frequency modulation patterns are generated downstream.
#'
#' @return This function returns the same data frame that was used as input for the function with an additional column of the string converted to Parsons code.
#'
#' @examples
#' seed <- 8
#' set.seed(seed) # For reproducibility
#' library(tidyverse)
#'
#' example_calls <- generate_strings(n_groups = 2, n_individuals = 5, n_calls = 10, string_length = 16, group_information = 8, individual_information = 2)
#'
#' example_calls_parsons <- parsons_code(example_calls, "Call", list("A" = "up", "B" = "down", "C" = "constant"))
#' glimpse(example_calls_parsons)
#'
#' @export parsons_code

parsons_code <- function(df, string_col, global_head_col, group_head_col, individual_middle_col, group_tail_col, global_tail_col, mapping = list("A" = "up", "B" = "down", "C" = "constant")) {
  
  if (!is.data.frame(df)) {
    stop("The 'df' argument must be a data frame.")
  }
  if (!is.list(mapping)) {
    stop("The 'mapping' argument must be a list.")
  }
  if (!string_col %in% colnames(df)) {
    stop(paste("Column", string_col, "does not exist in the data frame."))
  }
  if (!is.character(string_col)) {
    stop("The 'string_col' argument must be a character string.")
  }
  if (nrow(df) == 0) {
    stop("Input data frame is empty")
  }
  if (length(mapping) == 0) {
    stop("The 'mapping' list must contain at least one element.")
  }
  
  df %>%
    dplyr::mutate(Call_Parsons_Code = sapply(!!rlang::sym(string_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
    # Raneem's additions
    dplyr::mutate(Global_Head_Parsons_Code = sapply(!!rlang::sym(global_head_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
    dplyr::mutate(Group_Head_Parsons_Code = sapply(!!rlang::sym(group_head_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
    dplyr::mutate(Individual_Middle_Parsons_Code = sapply(!!rlang::sym(individual_middle_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
    dplyr::mutate(Group_Tail_Parsons_Code = sapply(!!rlang::sym(group_tail_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-"))) %>%
    dplyr::mutate(Global_Tail_Parsons_Code = sapply(!!rlang::sym(global_tail_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-")))
}

# Helper function to generate Parsons code for existing sequences
convert_to_parsons_code <- function(string, mapping) {
  sapply(strsplit(string, NULL)[[1]], function(char) mapping[[char]], USE.NAMES = FALSE)
}