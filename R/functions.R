#From line 1 to 77 are helper functions
generate_random_string <- function(call_length) {
  paste(sample(c("A", "B", "C"), call_length, replace = TRUE), collapse = "")
}

#this function generates strings with distance in relation to the base string generated by the 'generate_random_string' function.
generate_string_with_distance <- function(base_string, min_distance, max_distance) {
  repeat {
    new_string <- generate_random_string()
    distance <- stringdist::stringdist(base_string, new_string, method = "lv")
    if (distance >= min_distance && distance <= max_distance) {
      return(new_string)
    }
  }
}

parsons_code_mapping <- list(
  "A" = "up",
  "B" = "down",
  "C" = "constant"
)

#function to generate parsons code for existing sequences
convert_to_parsons_code <- function(string, mapping) {
  sapply(strsplit(string, NULL)[[1]], function(char) mapping[[char]], USE.NAMES = FALSE)
}

#function to convert frequency string to numeric vector
convert_frequency <- function(freq_str) {
  as.numeric(strsplit(freq_str, ",")[[1]])
}

# #use function on our df
# add_parsons_code <- function(df, string_col, mapping) {
#   df %>%
#     dplyr::mutate(Parsons_Code = sapply(!!rlang::sym(string_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-")))
# }

#extract and summarize heads, middles, and tails
summarize_calls <- function(calls_df, call_length, middle) {
  head_tail_length <- (call_length - middle) / 2

  calls_df <- calls_df %>%
    mutate(
      Head = substr(Call, 1, head_tail_length),
      Middle = substr(Call, head_tail_length + 1, head_tail_length + middle),
      Tail = substr(Call, call_length - head_tail_length + 1, call_length)
    )

  head_summary <- unique(calls_df$Head)
  tail_summary <- unique(calls_df$Tail)
  middle_summary <- calls_df %>%
    group_by(Individual) %>%
    summarize(Unique_Middles = n_distinct(Middle))

  list(
    Head_Summary = head_summary,
    Tail_Summary = tail_summary,
    Middle_Summary = middle_summary
  )
}



#Functions
#' Generate Parsons Code from character strings
#'
#' This function generates Parsons code from the character strings generated by the call_gen function.
#'
#' @param df data frame containing strings of "A", "B", "C".
#' @param string_col name of column containing strings.
#' @param mapping Parsons code mapping corresponding to strings.
#' @return A data frame containing Parsons Code based on the call column.
#' @examples
#' set.seed(3)  # For reproducibility
#' gd_calls_parsons <- add_parsons_code(gd_calls, "Call", parsons_code_mapping)
#' @export
add_parsons_code <- function(df, string_col, mapping) {
  df %>%
    dplyr::mutate(Parsons_Code = sapply(!!rlang::sym(string_col), function(string) paste(convert_to_parsons_code(string, mapping), collapse = "-")))
}


#' Generate Frequency Data Frame from Parsons Code Column
#'
#' This function takes a data frame and a column name containing Parsons code strings,
#' and generates a data frame that includes social and call metadata, as well as frequency values
#' based on the Parsons code conversion.
#'
#' @param df A data frame containing the Parsons code strings.
#' @param parsons_col The name of the column in the data frame containing Parsons code strings.
#' @param group_id_col The name of the column in the data frame containing numeric group IDs.
#' @param individual_id_col The name of the column in the data frame containing numeric individual IDs.
#' @param call_id_col The name of the column in the data frame containing unique numeric identifiers for each call per individual.
#' @param callNo_id_col The name of the column in the data frame specifying which number call an individual is on.
#' @return A data frame containing the group ID, individual ID, call ID,
#' the original Parsons code string, and one column per frequency value.
#' @examples
#' df <- data.frame(
#'   Parsons = c("up-down-constant-up", "down-up-constant-down"),
#'   GroupID = c(1, 1),
#'   IndividualID = c(101, 102),
#'   CallID = c(1, 2),
#'   stringsAsFactors = FALSE
#' )
#' generate_frequency(df, "Parsons", "GroupID", "IndividualID", "CallID")
#' @export

generate_frequency <- function(df, parsons_col, group_id_col, individual_id_col, call_id_col, callNo_id_col) {
  # Ensure column names are case-insensitive
  colnames(df) <- tolower(colnames(df))
  parsons_col <- tolower(parsons_col)
  group_id_col <- tolower(group_id_col)
  individual_id_col <- tolower(individual_id_col)
  call_id_col <- tolower(call_id_col)
  callNo_id_col <- tolower(callNo_id_col)
  
  # Initialize an empty list to store the results
  results <- list()
  
  # Iterate over each row in the data frame
  for (i in 1:nrow(df)) {
    parsons_code <- df[[parsons_col]][i]
    group_id <- df[[group_id_col]][i]
    individual_id <- df[[individual_id_col]][i]
    call_id <- df[[call_id_col]][i]
    callNo_id <- df[[callNo_id_col]][i]  # Fix: Added [i] to access specific row
    
    # Split the parsons_code string by dashes
    split_parsons_code <- strsplit(parsons_code, "-")[[1]]
    
    # Calculate the length of the split vector
    call_length <- length(split_parsons_code)
    
    # Initialize the frequencies vector with starting frequency 4000
    frequencies <- numeric(length(split_parsons_code) + 2)
    frequencies[1] <- 4000
    previous_value <- 4000
    
    # Set the increment value based on call_length
    increment <- if (call_length > 60) 100 else 1000
    
    # Iterate over the split parsons code to generate frequencies
    for (j in 1:call_length) {
      direction <- split_parsons_code[j]
      if (direction == "up") {
        frequency <- previous_value + increment
      } else if (direction == "down") {
        frequency <- previous_value - increment
      } else if (direction == "constant") {
        frequency <- previous_value
      } else {
        stop("Invalid direction: ", direction)
      }
      previous_value <- frequency
      frequencies[j + 1] <- frequency
    }
    
    # Add the final frequency value
    frequencies[length(frequencies)] <- 4000
    
    # Create a data frame with the metadata and frequency values for the current call
    freq_df <- data.frame(
      Group = group_id,
      Individual = individual_id,
      Call.No = callNo_id,
      Call = call_id,
      Parsons_Code = parsons_code,
      stringsAsFactors = FALSE
    )
    
    # Add frequency columns to the data frame
    for (k in 1:length(frequencies)) {  # Fix: Iterate over length of frequencies correctly
      freq_df[[paste0("Frequency", k)]] <- frequencies[k]
    }
    
    # Append the data frame to the results list
    results[[i]] <- freq_df
  }
  
  # Combine all results into a single data frame
  final_df <- do.call(rbind, results)
  
  return(final_df)
}



#' Generate Synthetic Signal and Save as WAV File
#'
#' This function generates a synthetic audio signal from a vector of frequencies
#' and saves it as a WAV file.
#'
#' @param frequencies A numeric vector of frequency values.
#' @param audio_filename The name of the output WAV file.
#' @param sampling_rate The sampling rate for the audio file.
#' @param sylLen The length of the syllable in milliseconds.
#' @return None
#' @examples
#' frequencies <- c(4000, 5000, 4000, 4000, 5000, 4000)
#' audio_filename <- "output.wav"
#' sampling_rate <- 150000
#' sylLen <- 200
#' gen_synth_signal(frequencies, audio_filename, sampling_rate, sylLen)
#' @export
gen_synth_signal <- function(frequencies, audio_filename, sampling_rate, sylLen) {
  # Adjust pitch floor and ceiling based on the sampling rate
  pitch_floor <- 1
  pitch_ceiling <- sampling_rate / 2

  # Generate waveform from frequency with the fixed sampling rate
  sound_wave <- suppressMessages(soundgen(
    pitch = frequencies,
    samplingRate = sampling_rate,
    sylLen = sylLen,
    pitchFloor = pitch_floor,
    pitchCeiling = pitch_ceiling,
    saveAudio = audio_filename
  ))
}

#' Generate and Save WAV Files for Each Call in the Data Frame
#'
#' This function loops through each row in the data frame and uses the `gen_synth_signal` function
#' to generate and save WAV files for each call.
#'
#' @param df A data frame containing the frequency values and metadata.
#' @param save_path The directory where the WAV files will be saved.
#' @param sampling_rate The sampling rate for the audio file.
#' @param sylLen The length of the syllable in milliseconds.
#' @param prefix A prefix to distinguish between individual-level and group-level audio files.
#' @return The input data frame, updated to have an additional column with the audio file name
#' @examples
#' individual_freq_df <- generate_frequency(individual_df, "Parsons", "GroupID", "IndividualID", "CallID")
#' generate_and_save_wav(individual_freq_df, "path/to/save/directory", 150000, 200, "individual")
#' @export
write_wave <- function(df, save_path, sampling_rate, sylLen, prefix = "call") {
  # Ensure the save path exists
  if (!dir.exists(save_path)) {
    dir.create(save_path, recursive = TRUE)
  }

  df2 <- data.table::rbindlist(lapply(1:nrow(df), function(i){
    # Extract frequencies from the data frame
    frequencies <- as.numeric(df[i, grep("^Frequency", colnames(df))])

    # Construct the audio filename with a unique identifier
    audio_filename <- paste0(prefix, "_Group", df$Group[i], "_Ind", df$Individual[i],"_Call", df$Call[i], ".wav")
    
    audio_pathname <- file.path(save_path, audio_filename)

    # Generate and save the WAV file
    gen_synth_signal(frequencies, audio_pathname, sampling_rate = sampling_rate, sylLen = sylLen)
    
    return(
      df[i, ] %>% 
        dplyr::mutate(
          audio_file_name = audio_filename
        )
    )
    
  }))
  
  return(df2)
  
}



#' Generate calls at both the individual and group level
#'
#' This function generates distinct calls at the group and individual level by pasting together random heads, middles, and tails for both groups and individuals.
#'
#' @param n_groups Integer. Number of groups.
#' @param n_individuals Integer. Number of individuals per group.
#' @param n_calls Integer. Number of calls per individual.
#' @param string_length Integer. Number of characters present in the string that encodes individual-level and group-level information through frequency modulation. Minimum is 6, maximum is 20.
#' @param gl_middle Integer. Number of characters that will vary in the middle of the string across groups. Default is 8.
#' @param il_middle Integer. Number of characters that will vary in the middle of the string within groups. Default is 2.
#' @return A data frame containing the group, individual, and call strings.
#' @examples
#' set.seed(3)  # For reproducibility
#' example_calls <- gen_calls(n_groups = 2, n_individuals = 5, n_calls = 10, string_length = 16, gl_middle = 8, il_middle = 2)
#' View(example_calls)
#' @export

gen_calls <- function(n_groups = 2, n_individuals = 5, n_calls = 10, string_length = 16, gl_middle = 8, il_middle = 2) {
  
  if (string_length < 6 || string_length > 200) {
    stop("string_length must be between 6 and 200")
  }
  
  if(missing(gl_middle)){
    stop("gl_middle must be specified")
  }
  
  if(missing(il_middle)){
    stop("il_middle must be specified")
  }

  # Create global header and tail strings. The length of these strings will vary depending on the length of the group-specific information (gl_middle) and the individual-specific information (il_middle)
  head_tail_length <- floor((string_length - gl_middle - il_middle) / 2)

  # Helper function to generate a random string
  generate_random_string <- function(length) {
    paste(sample(c("A", "B", "C"), length, replace = TRUE), collapse = "")
  }

  # Generate a single head and tail for all groups
  global_head <- generate_random_string(head_tail_length)
  # print(paste("Global Head:", global_head))
  global_tail <- generate_random_string(head_tail_length)
  # print(paste("Global Tail:", global_tail))

  if (gl_middle > 0) {
    # Generate distinct group middle sections
    group_middles <- character(n_groups)
    for (g in 1:n_groups) {
      group_middles[g] <- generate_random_string(gl_middle)
    }
    # print(paste("Group Middles:", group_middles))
  }

  calls <- character(n_groups * n_individuals * n_calls)
  groups <- rep(1:n_groups, each = n_individuals * n_calls)
  individuals <- numeric(n_groups * n_individuals * n_calls)
  call_numbers <- numeric(n_groups * n_individuals * n_calls)

  for (group in 1:n_groups) {
    for (ind in 1:n_individuals) {
      # Generate a unique middle part for each individual
      individual_middle <- generate_random_string(il_middle)
      # print(paste(individual_middle))
      if (gl_middle > 0) {
        group_middle_head_tail_length <- (gl_middle - il_middle) / 2
        individual_call <- paste0(
          global_head,
          substr(group_middles[group], 1, group_middle_head_tail_length),
          individual_middle,
          substr(group_middles[group], group_middle_head_tail_length + il_middle + 1, gl_middle),
          global_tail
        )
      } else {
        individual_call <- paste0(
          global_head,
          individual_middle,
          global_tail
        )
      }

      for (call in 1:n_calls) {
        idx <- ((group - 1) * n_individuals * n_calls) + ((ind - 1) * n_calls) + call
        calls[idx] <- individual_call
        individuals[idx] <- ind
        call_numbers[idx] <- call
      }
    }
  }

  data.frame(
    Group = groups,
    Individual = individuals,
    Call.No = call_numbers,
    Call = calls,
    stringsAsFactors = FALSE
  )
}
